Copy–paste this entire brief into Replit (or any codegen agent) as the single source of truth. Build exactly as specified.

⸻

PROJECT GOAL

Ship an MVP Western astrology daily prediction platform where:
	1.	The user creates a Western Equal-house chart from DOB/TOB/place → raw astro params (P) stored server-side (off-chain for MVP).
	2.	A user requests a daily prediction (for a specific date; default = today).
	3.	Exactly 2 agents return their daily prediction (random or reputation-weighted selection).
	4.	The user picks the better answer; the chosen agent’s reputation increases by +1.
	5.	Minimal, clean UI.

Western only. House system = Equal. Timezone-aware throughout.

⸻

TECH STACK
	•	ZK (optional v1, feature-flagged): Client-side proving with Circom/snarkjs (Groth16) or Noir; on-chain verifier on an L2 (e.g., Base/Polygon). Controlled by ZK_ENABLED=true|false. If enabled, the app mints the chart on-chain with raw params (P) + proof; otherwise it stores P in Postgres only.
	•	App: Next.js 14 (App Router) + TypeScript.
	•	API / Server: Next.js Route Handlers (Node runtime for astro calcs).
	•	DB: Neon Postgres (Prisma ORM). Provide local dev fallback via Docker, but default to Neon.
	•	Auth: NextAuth (Email magic link). Anonymous session (UUID) allowed; associate requests to user if authenticated.
	•	Astro engine: Node astronomia (VSOP87) for planetary longitudes; compute Equal houses; timezone with luxon.
	•	If astronomia is unavailable on Replit, include a fallback ephemeris JSON (Sun–Saturn hourly, 1950–2050) with linear interpolation.
	•	Agents / LLM: Two built-in agent adapters that compute daily scores + summaries. LLM provider = Perplexity (OpenAI-compatible Chat Completions). Env: PERPLEXITY_API_KEY. If not set, render rule-based text.
	•	Styling: TailwindCSS + shadcn/ui.
	•	Testing: Vitest + Playwright (smoke tests only).

⸻

CORE ENTITIES (Prisma schema)

model User {
  id         String   @id @default(cuid())
  email      String?  @unique
  createdAt  DateTime @default(now())
  reputation Int      @default(0)
  requests   PredictionRequest[]
}

model Chart { // raw parameter snapshot per user
  id              String   @id @default(cuid())
  userId          String?
  user            User?    @relation(fields: [userId], references: [id])
  inputsHash      String   // hash(DOB, TOB, lat, lon, salt)
  algoVersion     String   // 'western-equal-v1'
  paramsJson      Json     // P: planets, asc, mc (coarsened)
  createdAt       DateTime @default(now())
  // ZK / on-chain (optional)
  zkEnabled       Boolean  @default(false)
  ephemerisRoot   String?  // committed ephemeris Merkle/KZG root
  pCid            String?  // IPFS/Arweave CID if P stored off-chain
  chain           String?  // e.g., 'base-sepolia'
  chartIdOnChain  String?  // uint256 as string
  txHash          String?  // publish tx hash
}

model Agent {
  id          String   @id @default(cuid())
  handle      String   @unique
  method      String   // e.g., 'Western-Transit'
  description String
  reputation  Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
}

model PredictionRequest {
  id               String   @id @default(cuid())
  userId           String?
  user             User?    @relation(fields: [userId], references: [id])
  chartId          String
  chart            Chart    @relation(fields: [chartId], references: [id])
  question         String   // e.g., "How will my day go?"
  targetDate       DateTime // UTC date for the daily prediction
  createdAt        DateTime @default(now())
  status           String   @default("OPEN") // OPEN | ANSWERED | SETTLED
  answers          PredictionAnswer[]
  selectedAnswerId String?
}

model PredictionAnswer {
  id        String   @id @default(cuid())
  requestId String
  request   PredictionRequest @relation(fields: [requestId], references: [id])
  agentId   String
  agent     Agent    @relation(fields: [agentId], references: [id])
  summary   String   // 1–2 paragraph daily read
  highlights String  // bullet string ("- tip1\n- tip2")
  dayScore  Float    // 0..100 overall daily score
  factors   String   // short reasons e.g., "Moon trine Sun; Venus sextile ASC; Mercury retro"
  createdAt DateTime @default(now())
}

model ReputationEvent {
  id        String   @id @default(cuid())
  agentId   String
  agent     Agent    @relation(fields: [agentId], references: [id])
  requestId String
  delta     Int      // +1 on selection
  createdAt DateTime @default(now())
}


⸻

RAW PARAMS (P) SPEC (Western, Equal houses)

Store in Chart.paramsJson (coarsen to mitigate re-ID):

{
  "quant": "centi-deg",
  "zodiac": "tropical",
  "houseSystem": "equal",
  "planets": {"sun": 8321, "moon": 19732, "mercury": 9217, "venus": 15544, "mars": 4711, "jupiter": 30122, "saturn": 33029},
  "retro": {"mercury": false, "venus": false, "mars": false, "jupiter": false, "saturn": true},
  "asc": 1230,
  "mc": 900
}

	•	Compute from DOB/TOB/place; convert to UTC using luxon + tz database.
	•	Equal houses: House 1 cusp = Asc degree; each next cusp +30° mod 360.

⸻

API ROUTES (Next.js /api)

ZK CHART PROOF (Optional, feature-flagged)

When ZK_ENABLED=true, the server exposes a client-prover flow:
	•	Client computes P from DOB/TOB/place, then calls /api/zk/prove to obtain proving inputs (ephemeris chunk commitments).
	•	Client runs WASM prover (Circom or Noir) → produces proofChart and publicSignals (including coarsened P).
	•	Client POSTs to /api/zk/publish with { P, proofChart, inputsCommitment }.
	•	Server verifies locally, pins P to IPFS (returns pCid), and calls the on-chain ChartStore verifier to mint. Stores chartIdOnChain, txHash in Chart.

Contract fields (on-chain): inputsCommitment, ephemerisRoot, algoVersion, P (bytes or pCid), proofChart.

Env: ZK_ENABLED, EPHEMERIS_ROOT, ALGO_VERSION, CHARTSTORE_ADDRESS, CHAIN_RPC_URL, RELAYER_PRIVATE_KEY.

⸻

API ROUTES (Next.js /api)

All routes return JSON; use zod for validation.
	1.	POST /api/chart
Body: { dob: 'YYYY-MM-DD', tob: 'HH:mm', tz: string(IANA), place: {lat:number, lon:number}, privacyMode?: 'normal'|'strict', zk?: boolean }
Action: Compute P, hash inputs with random salt, persist Chart. If zk=true and ZK_ENABLED, return client instructions for proving (/api/zk/prove bootstrap). Otherwise store off-chain only.
Returns: { chartId, params: P, inputsHash, zk: { enabled, ephemerisRoot, algoVersion } }
	2.	POST /api/zk/prove (optional)
Body: { chartId }
Action: Returns canonical EPHEMERIS_ROOT, ALGO_VERSION, and any lookup commitments needed by the prover.
Returns: { ephemerisRoot, algoVersion, provingKeyInfo }
	3.	POST /api/zk/publish (optional)
Body: { chartId, P, inputsCommitment, proofChart }
Action: Verify proof locally; pin P to IPFS → pCid; call ChartStore.publishChart(...); update Chart with on-chain references.
Returns: { chartIdOnChain, txHash, pCid }
	4.	POST /api/request
Body: { chartId, question, targetDate?: 'YYYY-MM-DD' }
Action: Create PredictionRequest for the calendar day (default today in user tz → convert to UTC 00:00). Select 2 agents (see selection), generate daily answers, store as PredictionAnswers, set status ANSWERED when 2 exist.
Returns: { requestId }
	5.	GET /api/request/:id
Returns: request, chart summary, 2 answers with agent handles.
	6.	POST /api/request/:id/select
Body: { answerId }
Action: Mark selectedAnswerId=answerId, status SETTLED, increment chosen agent’s reputation (+1) and create a ReputationEvent.
Returns: { ok: true }
	7.	GET /api/agents
List agents with reputation.

⸻

AGENT SELECTION LOGIC
	•	On each /api/request:
	•	Pull active agents sorted by reputation desc.
	•	Sample 2 without replacement using weighted random: weight = 1 + reputation.
	•	If <2 agents exist, duplicate with different temperature settings (agent clones).

⸻

AGENT ANSWER GENERATION

Implement two adapters in lib/agents/:
	•	AgentA: Western daily transits scoring (focus: Sun/Moon/ASC contacts to natal; Jupiter/Venus bonuses; Mars/Saturn hard aspects penalties; Mercury retro penalty; lunar phase bias). Output one-day result.
	•	AgentB: Alternative weights (more conservative), same one-day output.

Each agent returns:

{
  summary: string,
  highlights: string, // markdown bullets
  dayScore: number,   // 0..100
  factors: string     // short reasons, e.g. "Moon trine Sun; Venus sextile ASC; Mercury retro"
}

If PERPLEXITY_API_KEY present: send (P, question, targetDate, scores/factors) to Perplexity’s Chat Completions for style polish; else use template text.

⸻

ASTRO SCORING (Western, Daily MVP)

For the target day only:

score(day) =
  + 3 * (benefic aspects of Jupiter/Venus to natal Sun/Moon/ASC)
  + 2 * (Sun/Moon harmonious aspects to natal Sun/Moon/ASC)
  - 3 * (Mars/Saturn square/opposition to Sun/Moon/ASC)
  - 2 * (Mercury retrograde on this day)
  + 1 * (waxing Moon) - 1 * (waning Moon)

	•	Aspects: orb 6° (conj/opp/square), 4° (trine), 3° (sextile).
	•	Output a single dayScore and concise factors list.

⸻

FRONTEND PAGES (App Router)
	•	/ Landing: create chart form (DOB/TOB/place/tz) → calls /api/chart.
	•	/chart/[id] Chart summary (planets in signs), button: “Ask for today’s (or chosen date) prediction”.
	•	/request/[id] Shows question, target date, and 2 agent answers side-by-side (Cards with summary, highlights, dayScore). CTA: Choose the best → calls /api/request/:id/select.
	•	/agents Leaderboard sorted by reputation.

UI notes:
	•	Minimal Tailwind + shadcn Cards, Buttons, Badge for reputation, Skeleton loaders while answers generate.
	•	Use optimistic updates.

⸻

FILE STRUCTURE

/ (Next.js app)
  app/
    ...
    api/zk/prove/route.ts      // optional ZK bootstrap
    api/zk/publish/route.ts    // optional ZK on-chain publish
  lib/zk/
    prover.ts                  // WASM loader, witness, proof generation
    verifyLocal.ts             // local verification before on-chain
    contracts.ts               // ethers client for ChartStore
  ...

/ (Next.js app)
  app/
    page.tsx
    chart/[id]/page.tsx
    request/[id]/page.tsx
    agents/page.tsx
  app/api/chart/route.ts
  app/api/request/route.ts
  app/api/request/[id]/route.ts
  app/api/request/[id]/select/route.ts
  app/api/agents/route.ts
  lib/astro/
    equalHouses.ts
    planets.ts  // astronomy calcs via `astronomia` or fallback ephemeris
    transits.ts // simple aspect checks + lunar phase
    scoring.ts  // score function
  lib/agents/
    agentA.ts
    agentB.ts
    llm.ts      // Perplexity client
  lib/db.ts     // Prisma client
  prisma/
    schema.prisma
    seed.ts
  scripts/
    generate-ephemeris.ts // optional fallback JSON generator
  tests/
    api.spec.ts
    e2e.spec.ts
  README.md


⸻

ENV & CONFIG

.env keys (example):

DATABASE_URL="<your Neon Postgres connection string>"
NEXTAUTH_SECRET=dev-secret
PERPLEXITY_API_KEY=optional

# Optional ZK + chain
ZK_ENABLED=false
EPHEMERIS_ROOT=0x<merkle_or_kzg_root>
ALGO_VERSION=western-equal-v1
CHARTSTORE_ADDRESS=0x<deployed_verifier_contract>
CHAIN_RPC_URL=https://<l2-rpc>
RELAYER_PRIVATE_KEY=0x<private_key_for_tx>

.env keys (example):

DATABASE_URL="<your Neon Postgres connection string>"
NEXTAUTH_SECRET=dev-secret
PERPLEXITY_API_KEY=optional


⸻

SEED DATA
	•	Seed exactly 2 active Agents: @auriga and @nova with different reputations.
	•	Include 2–3 demo Charts for quick UI tests.

⸻

ACCEPTANCE CRITERIA (MVP)
	•	Create chart from DOB/TOB/place → persists Chart with computed P.
	•	Create prediction request → exactly 2 answers are stored and retrievable within ~3s (simulate async if needed).
	•	User selects best answer → chosen agent’s reputation increments by +1; ReputationEvent recorded.
	•	Agents page shows leaderboard by reputation.
	•	Works with and without PERPLEXITY_API_KEY (template fallback).
	•	Simple mobile-friendly UI.
	•	Unit test for scoring + API test for request lifecycle passes.

ZK (optional) acceptance:
	•	When ZK_ENABLED=true, /api/chart returns ephemeris root + algo version and allows client proving.
	•	/api/zk/publish verifies proof, pins P to IPFS, and publishes to ChartStore; DB stores chartIdOnChain + txHash.
	•	Create chart from DOB/TOB/place → persists Chart with computed P.
	•	Create prediction request → exactly 2 answers are stored and retrievable within ~3s (simulate async if needed).
	•	User selects best answer → chosen agent’s reputation increments by +1; ReputationEvent recorded.
	•	Agents page shows leaderboard by reputation.
	•	Works with and without PERPLEXITY_API_KEY (template fallback).
	•	Simple mobile-friendly UI.
	•	Unit test for scoring + API test for request lifecycle passes.

⸻

README CONTENT (authoring instructions)

Explain:
	•	What the Western Equal-house daily MVP does.
	•	How to run: pnpm i && pnpm dev; how to configure Neon in .env and run prisma migrate dev.
	•	How to run tests.

⸻

DEV NOTES
	•	All datetime I/O must be timezone-aware (IANA tz). Store UTC in DB, display local on client.
	•	If TOB is unknown, either (a) require it for MVP, or (b) use 12:00 and set paramsJson.meta.approxTime=true.
	•	Keep code clean, documented, and typed.

⸻

DELIVERABLE

A working Next.js repo meeting acceptance criteria, ready to deploy on Replit or Vercel.